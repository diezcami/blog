
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>C++ Pointers and References: An Overview - Camille Diez</title>
  <meta name="author" content="Camille Diez">

  
  <meta name="description" content="References and pointers are usually, in one way or another, implemented in every programming language; higher level languages, however, most likely &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://diezcami.github.io/blog/2015/05/08/c-plus-plus-pointers-and-references-an-overview">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Camille Diez" type="application/atom+xml">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/blog/blog">Camille Diez</a></h1>
  
    <h2>Beef Bowls and Iced Tea</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
<ul class="subscribe">
  <li><a href="https://github.com/diezcami" rel="subscribe-github" title="@diezcami on GitHub" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 50,0 C 22.385714,0 0,22.385714 0,50 0,77.614286 22.385714,100 50,100 77.614286,100 100,77.614286 100,50 100,22.385714 77.614286,0 50,0 z m 29.692858,79.692858 c -3.859184,3.859182 -8.351022,6.887754 -13.35,9.00306 -1.27041,0.536736 -2.560204,1.009184 -3.867348,1.415306 v -7.493878 c 0,-3.938774 -1.35102,-6.835714 -4.053062,-8.690816 1.692858,-0.163264 3.24694,-0.390816 4.663266,-0.683672 1.416326,-0.292858 2.913266,-0.716328 4.491838,-1.27041 1.57857,-0.55408 2.994896,-1.213264 4.247958,-1.97755 1.253062,-0.765306 2.458164,-1.758164 3.613266,-2.978572 1.155102,-1.220408 2.12449,-2.604082 2.905102,-4.15 0.780612,-1.545918 1.4,-3.40204 1.855102,-5.566326 0.455102,-2.164286 0.683674,-4.54898 0.683674,-7.153062 0,-5.045918 -1.643878,-9.341836 -4.931634,-12.890816 C 77.44796,33.35 77.285714,29.10204 75.463266,24.512244 l -1.22143,-0.145918 c -0.845918,-0.09796 -2.368366,0.260204 -4.565306,1.07449 -2.196938,0.814286 -4.663264,2.14796 -7.396938,4.004082 -3.87449,-1.07449 -7.893878,-1.611224 -12.061224,-1.611224 -4.19898,0 -8.203062,0.536734 -12.012246,1.611224 -1.72449,-1.17245 -3.361224,-2.139796 -4.907142,-2.905102 C 31.753062,25.77449 30.516326,25.254082 29.587756,24.97653 28.660204,24.7 27.79796,24.528572 27,24.463266 c -0.79796,-0.0653 -1.310204,-0.08062 -1.537756,-0.04898 -0.22755,0.03164 -0.390816,0.0653 -0.487754,0.09796 -1.82347,4.62245 -1.985714,8.87143 -0.487756,12.743878 -3.287754,3.54796 -4.931632,7.844898 -4.931632,12.890816 0,2.604082 0.227552,4.988776 0.683674,7.153062 0.456122,2.164286 1.07449,4.020408 1.855102,5.566326 0.780612,1.545918 1.75,2.929592 2.905102,4.15 1.155102,1.220408 2.360204,2.213266 3.613264,2.978572 1.253062,0.766326 2.669388,1.42449 4.24796,1.97755 1.578572,0.554082 3.07551,0.976532 4.491836,1.27041 1.416328,0.292856 2.970408,0.521428 4.663266,0.683672 -2.669388,1.82347 -4.004082,4.720408 -4.004082,8.690816 v 7.639796 C 36.536734,89.818368 35.083674,89.3 33.656122,88.695918 c -4.99898,-2.115306 -9.490816,-5.143878 -13.35,-9.00306 -3.859184,-3.859184 -6.887754,-8.351022 -9.00306,-13.35 C 9.1163263,61.171428 8.0071428,55.67347 8.0071428,50 c 0,-5.67347 1.1091835,-11.171428 3.2969392,-16.342858 2.115306,-4.998978 5.143878,-9.490816 9.00306,-13.35 3.859184,-3.859182 8.351022,-6.887754 13.35,-9.00306 C 38.828572,9.1163266 44.32653,8.0071428 50,8.0071428 c 5.67347,0 11.171428,1.1091838 16.342858,3.2969392 5,2.115306 9.490816,5.143878 13.35,9.00306 3.859182,3.859184 6.887754,8.351022 9.00306,13.35 2.186736,5.17245 3.295918,10.67041 3.295918,16.342858 0,5.672448 -1.109182,11.171428 -3.296938,16.342858 -2.115306,4.998978 -5.143878,9.490816 -9.00204,13.35 l 0,0 z"></path></svg></a></li>
</ul>
  
  
  
  
  
  
  
  
    
      <form action="https://www.google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="diezcami.github.io/blog" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/blog/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">C++ Pointers and References: An Overview</h1>
      
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-08T11:33:15+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:33 am</span></time>
        
         | <a href="#disqus_thread">Comments</a>
        
        
      </p>
    
  </header>


<div class="entry-content"><p>References and pointers are usually, in one way or another, implemented in every programming language; higher level languages, however, most likely do not provide explicit access to them. As a result, they often come up implicitly in the form of garbage collection and simpler OOP conventions. On the other hand, languages that have more freedom at lower levels such as C/C++ allow users to explicitly use pointers and references to manually control several aspects of a program including, but not limited to memory management/allocation, OOP and ease of access.</p>

<p>This guide is split into two parts - here, I&rsquo;ll be going through a basic overview on pointers and references understandable to anyone with knowledge on basic programming in any language and minor C++ syntax (mainly std, cout and endl).</p>

<!-- more -->


<h2>Pointers</h2>

<p>Every declared variable in a program, whether primitive or not, is stored in memory and has its own memory address in the form of a hexadecimal number (0x). These variables are normally accessed by identifiers they&rsquo;ve been declared with, paying no attention to its location in memory. To access the memory address of a variable in C++, we use the referencing operator <code>&amp;</code>.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::string foo = "foo";
</span><span class='line'>std::cout &lt;&lt; &foo &lt;&lt; std::endl; // output: memory address of foo</span></code></pre></td></tr></table></div></figure>


<p>A <strong>Pointer</strong> is a variable that holds a memory address. Its behavior is relatable to how entries in a table of contents contain page numbers or addresses that lead to actual content. It can be declared with or without being defined using <code>data_type *identifier</code>. To get the variable stored in a pointer, we use the dereferencing operator <code>*</code>. Note that the <code>*</code> being used as an operator and as part of a pointer&rsquo;s declaration are independent of each other.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int num = 10;
</span><span class='line'>int *foo;
</span><span class='line'>int bar*; 
</span><span class='line'>std::cout &lt;&lt; foo &lt;&lt; std::endl; // output: 0x0 (null memory address)
</span><span class='line'>
</span><span class='line'>foo = &num; 
</span><span class='line'>std::cout &lt;&lt; foo &lt;&lt; std::endl; // output: memory address of num
</span><span class='line'>std::cout &lt;&lt; *foo &lt;&lt; std::endl; //output: 10</span></code></pre></td></tr></table></div></figure>


<p>Pointers are not limited to being assigned by memory addresses derived from the <code>&amp;</code> operator - they can also be assigned with the memory addresses stored in other pointers. If a pointer is assigned to another pointer, any changes to the variable stored in the common memory address will reflect on the <code>*</code> operation of either pointer. This behavior is reminiscent of how objects are handled handled in Java;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::string qux = "Tempura";
</span><span class='line'>std::string *foo, *bar;
</span><span class='line'>
</span><span class='line'>foo = &qux;
</span><span class='line'>bar = foo;
</span><span class='line'>std::cout &lt;&lt; *foo &lt;&lt; std::endl; // output: Tempura
</span><span class='line'>std::cout &lt;&lt; *bar &lt;&lt; std:: endl; // output: Tempura
</span><span class='line'>
</span><span class='line'>qux = "Tonkatsu";
</span><span class='line'>std::cout &lt;&lt; *foo &lt;&lt; std::endl; // output: Tonkatsu
</span><span class='line'>std::cout &lt;&lt; *bar &lt;&lt; std:: endl; // output: Tonkatsu</span></code></pre></td></tr></table></div></figure>


<p>The deferencing operator <code>*</code> can also be used at the left hand side of operations to replace the values stored in a pointer or memory address. The referencing operator <code>&amp;</code>, however, cannot as it would not make sense to reallocate where a variable would be stored in memory. The following is a continuation of the code snippet above:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Recall that foo = &qux
</span><span class='line'>*foo = "Gyudon";
</span><span class='line'>std::cout &lt;&lt; qux &lt;&lt; std::endl; // output: Gyudon</span></code></pre></td></tr></table></div></figure>


<h2>Pointer Practices</h2>

<p>When using pointers regardless of how simple its applications are, it&rsquo;s paramount to take caution in remembering where a pointer comes from and goes towards during assignments. Carelessness here will lead to dangling pointers and memory leaks, which can be detrimental to your program&rsquo;s performance at best, and your whole computer&rsquo;s at worst. As good practice, the two main points to remember when using pointers are the following:</p>

<ul>
<li><strong>Deallocating memory</strong> used by an object a pointer points to using <code>delete pointer_to_obj</code> or <code>delete[] pointer_to_obj</code> after its usage to avoid memory leaks</li>
<li><strong>Setting a pointer to <code>null</code></strong> after its usage to avoid dangling pointers</li>
</ul>


<p>It&rsquo;s important to note that either <code>delete</code> function is actually interpreted as <strong>delete the object stored in pointer (arg)</strong>, which is entirely different from deleting the pointer itself. It&rsquo;s also important to note that either <code>delete</code> function only works on objects allocated with <code>new</code>. We use <code>delete</code> for variables that take up one block of space (eg. int, double, subclasses) and <code>delete[]</code> for array-based variables (eg. string, int[]). The following code snippet shows an example of inaccessible memory:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::string *bar = new std::string;
</span><span class='line'>*bar = "..";
</span><span class='line'>std::cout &lt;&lt; *bar &lt;&lt; std::endl; 
</span><span class='line'>bar = null;</span></code></pre></td></tr></table></div></figure>


<p>In the example above, the string <code>..</code> was initialized at the memory address stored in the pointer <code>bar</code>. After pointing <code>bar</code> to null (as stated in the second point in the guideline), there&rsquo;s nothing left that points to the memory storing the string containing <code>..</code>, making it impossible to deallocate and forced to remain in the RAM throughout the whole duration of the program. These situations are called <strong>Memory Leaks</strong>, and can be remedied by following the first guideline as stated earlier as seen below:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::string *bar = new std::string;
</span><span class='line'>*bar = "..";
</span><span class='line'>std::cout &lt;&lt; *bar &lt;&lt; std::endl; 
</span><span class='line'>delete bar; // deletes the object pointed to by bar, not bar itself
</span><span class='line'>bar = null</span></code></pre></td></tr></table></div></figure>


<p>Another type of problem presented by mishandling pointers is the <strong>Dangling Pointer</strong>, which happens when an pointer points to a memory address that, at the time of accessing, has not been allocated. It&rsquo;s important to note that not being allocated is not equivalent to pointing to null. The following code snippet shows an example of a dangling pointer:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int *bar = new int(5);
</span><span class='line'>delete bar;</span></code></pre></td></tr></table></div></figure>


<p>Since the memory address stored in <code>bar</code> has been freed with <code>delete bar</code>, <code>bar</code> now points to a deallocated memory address. Dereferencing or assigning the address at this point may be unsafe and result in <strong>undefined behavior</strong>, so it&rsquo;s better to set <code>bar</code> to <code>null</code> to stay on the safer side of memory management.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int *bar = new int(5);
</span><span class='line'>delete bar;
</span><span class='line'>bar = 0;
</span><span class='line'>std::cout &lt;&lt; bar &lt;&lt; std::endl; // Output: 0x0 (null)</span></code></pre></td></tr></table></div></figure>


<p>Beyond the band-aid fix of setting a pointer to null, however, it would be better to modify the code in a way that there would be no need to set the pointer to null to begin with.
Most examples here are trivial and meant to showcase pointer syntax above anything else. In reality, pointers can be used in OOP and to allocate memory in more resource-hungry programs to maximise their performance.</p>

<h2>References</h2>

<p>A <strong>Reference</strong> holds another variable of the same declared type, and serves as its alias. Its behavior is relatable to how a person can (but may not) be referred to by multiple nicknames or aliases while maintaining one full name. It can be declared and must be defined using <code>data_type &amp;identifier</code>. Similarly with <code>*</code>, note that the <code>&amp;</code> used when declaring a reference is not the same as the referencing operator <code>&amp;</code> used in the earlier examples. Unlike pointers, a reference cannot be null or re-assigned after being defined.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>std::string foo = "..";
</span><span class='line'>std::string& bar = foo;
</span><span class='line'>
</span><span class='line'>bool foobar = (foo==bar);
</span><span class='line'>std::cout &lt;&lt; foobar &lt;&lt; std::endl; // output: 1</span></code></pre></td></tr></table></div></figure>


<p>In a way, references work similarly to pointers with more limitations and are <code>const</code> in nature. The existence of references, however, is not fully redundant - operations involving references are generally safer than those involving pointers, and are usually used unless the situation demands functions exclusive to pointers (recall how pointers can be reassigned, while references cannot). References are also generally easier to use, as there&rsquo;s no need to keep track of dangling pointers or inaccessible memory. While I won&rsquo;t be going through the in-depth uses of references, I&rsquo;ve written one instance that showcases their functionality and definition well.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap_val (int foo, int bar) {
</span><span class='line'>    int qux = foo;
</span><span class='line'>    foo = bar;
</span><span class='line'>    bar = qux;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>When the above function <code>swap_val (a, b)</code> is called in an external function, the parameters <code>foo</code> and <code>bar</code> are merely copies of the values stored in <code>a</code> and <code>b</code>. As a result, calling this function will not result in swapping the actual values of <code>a</code> and <code>b</code> outside the function. When this behaviour happens in a function, it&rsquo;s said that its parameters <strong>pass by value</strong>. In the alternative function below,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void swap_ref (int &foo, int &bar) {
</span><span class='line'>    int qux = foo;
</span><span class='line'>    foo = bar;
</span><span class='line'>    bar = qux;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Notice that references are passed instead of actual <code>int</code> parameters. When <code>swap_ref (a, b)</code> is called, what&rsquo;s passed to the function are <em>references to a and b</em>, and not just copies of their values. When this behavior occurs, a function&rsquo;s parameters are said to <strong>pass by value</strong>. Now, when the function calls operations on references of <code>a</code> and <code>b</code>, they are actually called on the variables <code>a</code> and <code>b</code> passed as parameters as well. As a result,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int foo = 10;
</span><span class='line'>int bar = 20;
</span><span class='line'>swap_val (foo, bar);
</span><span class='line'>std::cout &lt;&lt; foo &lt;&lt; std::endl; // Output: 10
</span><span class='line'>std::cout &lt;&lt; bar &lt;&lt; std::endl; // Output: 20
</span><span class='line'>
</span><span class='line'>swap_ref (foo, bar);
</span><span class='line'>swap_val (foo, bar);
</span><span class='line'>std::cout &lt;&lt; foo &lt;&lt; std::endl; // Output: 20
</span><span class='line'>std::cout &lt;&lt; bar &lt;&lt; std::endl; // Output: 10  </span></code></pre></td></tr></table></div></figure>


<p>References are normally inaccessible in languages that maintain high level functionalities (including Java), making the language <strong>pass by value</strong> as a whole by default. What&rsquo;s good about the availability of access to references in C++ is the option to pass parameters either by value or by reference to functions, resulting in more versatile ways to code.</p>

<h2>Summary</h2>

<p>Here&rsquo;s a list of the terminologies used throughout the article:</p>

<table>
    <tr>
        <td><strong>TERM</strong></td>
        <td><strong>SAMPLE USAGE</strong></td>
        <td><strong>DEFINITION</strong></td>
    </tr>

    <tr>
        <td>Pointer</td>
        <td><code>int *foo</code></td>
        <td>A data type that stores a memory address</td>
    </tr>

    <tr>
        <td>Reference (noun)</td>
        <td><code>int &foo</code></td>
        <td>A data type that serves as an alias to another variable</td>

    </tr>



    <tr>
        <td>Dereference</td>
        <td><code>*bar</code></td>
        <td>To get the object stored in a memory address or pointer with the <code>*</code> operator</td>
    </tr>

    <tr>
        <td>Memory Leak</td>
        <td><code>n/a</code></td>
        <td>Result of memory addresses that can no longer be accessed and deallocated</td>
    </tr>

    <tr>
        <td>Dangling Pointers</td>
        <td><code>n/a</code></td>
        <td>Result of deallocating a memory address a pointer is pointing to</td>
    </tr>

    <tr>
        <td>Undefined Behavior</td>
        <td><code>n/a</code></td>
        <td>Result of illogical operations (eg. dereferencing a dangling pointer)</td>
    </tr>

    <tr>
        <td>Pass</td>
        <td><code>foo (a, b)</code></td>
        <td>Action taken on parameters used when calling a function</td>
    </tr>

    <tr>
        <td>Pass by Value</td>
        <td><code>void (int foo)</code></td>
        <td>Behavior in which functions operate on copies or clones of passed parameters</td>
    </tr>

    <tr>
        <td>Pass by Reference </td>
        <td><code>void (int &foo)</code></td>
        <td>Behavior in which functions operate on aliases leading to the passed parameters</td>
    </tr>

</table>


<h2>Further Reading</h2>

<p>There&rsquo;re a number of common applications for references and pointers that I did not cover in this entry - here&rsquo;s a small list of those:</p>

<ul>
<li><strong>Memory Management: Stacks and Heaps</strong>: In short, normal declared variables are allocated to the stack while variables called with <code>new</code> and pointers are allocated in the heap. Reading up on this will allow you to have a better understanding of what happens on a lower level beyond the the code and how memory is managed through code.</li>
<li><strong>Nesting (de)referencing operators</strong>: It&rsquo;s possible to call data types such as <code>type **identifier</code> to create a pointer to a pointer, or to use combinations of <code>&amp;</code> and <code>*</code> to create variable types that may eventually come in handy. Understanding how nested operators work will also provide a stronger foundation in C++ OOP than what&rsquo;s covered in this article.</li>
<li><strong>Pointers and Arrays</strong>: These two are closely related and reading up on them can explain the similarities in data types such as <code>char *</code> and <code>int *</code> when declaring an array or a pointer.</li>
<li><strong>Parameters and Return Values</strong>: Pointers and References, like any other variable, can be used as parameters and return values when implementing functions. You will likely encounter terms such as <em>pass by value</em> and <em>pass by reference</em>, which were introduced briefly earlier in this guide.</li>
<li><strong>Smart Pointers</strong>: More modern pointers that can be configured to or automatically delete pointers after a specified event. These, for the most part, get rid of the dangerous side of memory management that come with using regular pointers.</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  



  <span class="byline author vcard">Authored by <span class="fn">
  
    Camille Diez
  
  </span></span>


      




<time class='entry-date' datetime='2015-05-08T11:33:15+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:33 am</span></time>
      
      

<span class="categories">
  
    <a class='category' href='/blog/categories/c-plus-plus/'>c++</a>, <a class='category' href='/blog/categories/programming/'>programming</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/04/28/osx-fixing-slow-wakes-and-automatic-shutdowns/" title="Previous Post: OSX: Fixing Slow Wakes and Automatic Shutdowns">&laquo; OSX: Fixing Slow Wakes and Automatic Shutdowns</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/05/11/why-programming-is-hard/" title="Next Post: Why Learning how to Program is Hard">Why Learning how to Program is Hard &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 Camille Diez 
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'diezcami';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://diezcami.github.io/blog/2015/05/08/c-plus-plus-pointers-and-references-an-overview/';
        var disqus_url = 'http://diezcami.github.io/blog/2015/05/08/c-plus-plus-pointers-and-references-an-overview/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>

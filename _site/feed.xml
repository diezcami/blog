<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Camille Diez</title>
    <description>Software Development, General Programming and Unix
</description>
    <link>http://diezcami.github.io/blog/</link>
    <atom:link href="http://diezcami.github.io/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 27 May 2015 19:33:13 +0800</pubDate>
    <lastBuildDate>Wed, 27 May 2015 19:33:13 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>A Quick Guide to Aliasing Terminal Commands</title>
        <description>&lt;p&gt;This guide will probably only be useful to you if you find yourself using the &lt;strong&gt;Terminal&lt;/strong&gt; a lot whether on Linux/OS X. Here, I&amp;#39;ll be talking about aliases and how you could use them in your daily work to maximize your productivity and, to an extent, maintain your sanity while working with a mountain of commands.&lt;/p&gt;

&lt;h2&gt;What is Aliasing?&lt;/h2&gt;

&lt;p&gt;Aliasing a command is rather self explanatory - it&amp;#39;s the act of defining a nickname or alias to a certain set of commands via the Terminal. For instance, take a look at the following command I&amp;#39;ve been using frequently these past few days:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;g++ -std=c++11 *.cpp -o output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As someone who started compiling C++ with &lt;code&gt;make&lt;/code&gt; and only recently moved on to &lt;code&gt;g++&lt;/code&gt; to handle multiple files, the additional &lt;code&gt;std=c++11&lt;/code&gt; parameter was simply too tedious for me to type every time I wanted to compile a project on a new Terminal window. Call me lazy, but I&amp;#39;ve been spoiled with the likes of &lt;code&gt;javac&lt;/code&gt;, &lt;code&gt;ruby&lt;/code&gt; and &lt;code&gt;python&lt;/code&gt; for a couple of years now, and would like to have a similarly short compile command for C++. Luckily, a Terminal command actually exists to cure my predicament:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;alias g++11=&amp;quot;g++ -std=c++11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;alias&lt;/code&gt; command is pretty straightforward - it aliases the text &lt;code&gt;g++ -std=c++11&lt;/code&gt; into an alias &lt;code&gt;g++11&lt;/code&gt;. From now on, as long as I remain in the same Terminal window, I can compile files in C++ with the following command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;g++11 *.cpp -o output
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It&amp;#39;s important to know that these &lt;code&gt;alias&lt;/code&gt; commands will only remain in effect while the terminal windows they&amp;#39;ve been typed in remain open. This probably wouldn&amp;#39;t bother you if you don&amp;#39;t plan on using the defined aliases beyond the timeline of a short project - if you find yourself needing to use multiple commands on a daily basis, however, you&amp;#39;ll be glad to know there&amp;#39;s a way to permanently retain these aliases.&lt;/p&gt;

&lt;h2&gt;For Linux&lt;/h2&gt;

&lt;p&gt;To make aliases permanent in Linux or any of its distros, just append the &lt;code&gt;alias&lt;/code&gt; commands to the end of your &lt;code&gt;.bashrc&lt;/code&gt; file. To do this, open a Terminal window, type &lt;code&gt;nano ~/.bashrc&lt;/code&gt; and append your &lt;code&gt;alias&lt;/code&gt; commands to the end of the file. You can add multiple aliases, though you&amp;#39;d probably want to leave comments for each of them to avoid getting them mixed up.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;~/.bashrc
# This is a comment, by the way. You can use it to label your aliases.
...

# This alias is for compiling C++ files.
alias g++11=&amp;quot;g++ -std=c++11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When you&amp;#39;re done, save the file using &lt;code&gt;Ctrl+X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, and &lt;code&gt;Enter&lt;/code&gt;. Restart your Terminal or your machine, and you&amp;#39;ll find that &lt;code&gt;g++11&lt;/code&gt; or whatever aliases you&amp;#39;ve declared are now permanently recognized by the system. To remove an alias, open the &lt;code&gt;.bashrc&lt;/code&gt; file again and delete any alias entries you no longer want to keep.&lt;/p&gt;

&lt;h2&gt;For OS X&lt;/h2&gt;

&lt;p&gt;The procedure retain aliases in OS X is similar to that of Linux; however, the &lt;code&gt;alias&lt;/code&gt; commands need to be entered in the &lt;code&gt;.bash_profile&lt;/code&gt; file instead &lt;code&gt;.bashrc&lt;/code&gt;. To do this, open terminal and type &lt;code&gt;nano ~/.bash_profile&lt;/code&gt; and append your &lt;code&gt;alias&lt;/code&gt; commands to the end of the file. Like Linux, you can add comments as well as multiple aliases to the &lt;code&gt;.bash_profile&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;~/.bash_profile
...
# The process is exactly the same!
alias g++11=&amp;quot;g++ -std=c++11&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When you&amp;#39;re done, save the file using &lt;code&gt;Ctrl+X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, and &lt;code&gt;Return&lt;/code&gt;. Afterwards, restart your Terminal or machine, and you&amp;#39;re done! The removal process is also the same as that of Linux. As a final note, be careful not to alias your commands with the names of existing commands.&lt;/p&gt;

&lt;p&gt;Thanks for reading my guide!&lt;/p&gt;
</description>
        <pubDate>Tue, 19 May 2015 02:34:25 +0800</pubDate>
        <link>http://diezcami.github.io/blog/unix/osx/linux/2015/05/19/a-quick-guide-to-aliasing-terminal-commands.html</link>
        <guid isPermaLink="true">http://diezcami.github.io/blog/unix/osx/linux/2015/05/19/a-quick-guide-to-aliasing-terminal-commands.html</guid>
        
        
        <category>unix</category>
        
        <category>osx</category>
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>Why Learning how to Program is Hard</title>
        <description>&lt;p&gt;I believe learning how to program is manageable in this day and age, with just about every answer being one google search away - there&amp;#39;s a multitude of free books, videos and even courses available online for any topic under programming, and even a website literally created to have people solve any kind of programming inquiry or problem you&amp;#39;ve had. Despite this, it&amp;#39;s not uncommon to hear people say how programming is difficult, and (for the extremes) how anyone who says otherwise is a liar.&lt;/p&gt;

&lt;p&gt;Don&amp;#39;t get me wrong; while I do think it&amp;#39;s manageable, I still believe learning how to program can easily be made difficult due to a certain trend of circumstances - take it from someone who got a C in an introductory course to programming.&lt;/p&gt;

&lt;p&gt;What&amp;#39;s easy to forget after learning numerous languages, frameworks and concepts is how daunting programming looks to someone not familiar with it. The start of anyone&amp;#39;s programming career, which mainly involves learning a programming language, can be daunting enough to weed a significant number of people away from the industry. For instance, take a look at the &amp;quot;Hello World&amp;quot; code of Java, a relatively common language both in the industry and as a coding language of instruction.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;public class Main {
    public static void main (String args[]) {
        System.out.println (&amp;quot;Hello, World!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When I first typed this, I absolutely could not fathom what was going on, and could only infer what the code meant from cue words like &lt;code&gt;println&lt;/code&gt;. When I checked google for the meaning of the rest of the syntax, I saw concepts such as classes, the main method, access modifiers, string arrays and even &lt;code&gt;return&lt;/code&gt; in the simplest explanations among the top search results. Then again, no matter how simple an explanation could be for these concepts, it&amp;#39;d be daunting for anyone who just learned how to compile code to read about them, let alone remember them. &lt;/p&gt;

&lt;p&gt;Eventually, I accepted that I would come across numerous concepts that would be cleared up in time, and how I simply had to stick it out until it&amp;#39;s appropriate to learn them. The practice of typing foreign syntax that &amp;quot;just worked&amp;quot; continued to the point where I did not know or care about what constituted a good, working code. My priorities then shifted from understanding every line of code I&amp;#39;ve written to just getting the program to compile. Afterall, I found it difficult to care about the syntax of my code when my course then focused on honing my problem solving skills, and gave me perfect marks in spite of submitting badly written code.&lt;/p&gt;

&lt;p&gt;My main point in sharing my experience is to demonstrate a small subset of what a person has to juggle when &lt;strong&gt;beginning&lt;/strong&gt; to learn how to program. Aside from learning the syntax of a language with no sense of familiarity whatsoever, new programmers are also expected to become accustomed to problem solving methods that aren&amp;#39;t common to life outside code (eg. Nested loops, recursion), to learn core concepts (eg. OOP), and to remember good coding practices (eg. usage of global variables, remembering built-in methods and data types, reading API). These standards, when unaccompanied by the guidance of a &lt;em&gt;capable&lt;/em&gt; professor or tutor, do not only push a person to their learning limit - they also force him to stick through the constant feelings of frustration, inadequacy and being overwhelmed without any promise of things eventually getting easier. After all, it wouldn&amp;#39;t be unreasonable for people of any aptitude to expect the beginning and adjusting period of learning a practice to be simple and unaccompanied with a large amount of negativity.&lt;/p&gt;

&lt;p&gt;What people don&amp;#39;t normally expect is how the learning curve, while unending, eventually becomes less steep - instead, thoughts of how programming &amp;quot;just isn&amp;#39;t for them&amp;quot; or &amp;quot;is just too hard&amp;quot; flow through their heads with the constant negativity they&amp;#39;re subjected to. Combine this with being exposed to people who seem to know what they&amp;#39;re doing with their code and seem to just &amp;quot;get&amp;quot; programming, and you&amp;#39;ll understand why it&amp;#39;s not uncommon for people to drop out of CS or programming early as a whole.&lt;/p&gt;

&lt;p&gt;I&amp;#39;d like to conclude with a message to anyone currently in the process of learning how to program for the first time: the frustration is normal, no matter how fundamental knowing primitive data types, learning how to create method signatures or other basic concepts may be. People honestly don&amp;#39;t give enough credit to learning the basics as opposed to learning the more advanced concepts of programming, and that&amp;#39;s normal as well. The feeling of &amp;quot;not being good enough&amp;quot; or &amp;quot;not knowing enough&amp;quot; will eventually be remedied by getting the hang of programming as a whole, which can only be done over time. The indicator of a good programmer is not someone who knows the whole breadth and depth of all programming concepts, but someone constantly able to adapt to any kind of new technology that pops up in the industry.&lt;/p&gt;

&lt;p&gt;That being said, relax! Programming is a one trick pony that makes you know less as you learn more - and the sooner you&amp;#39;re comfortable with coding and the uncertainty that comes with it, the better you&amp;#39;ll become at handling any kind of problem thrown at you in time.&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 15:14:57 +0800</pubDate>
        <link>http://diezcami.github.io/blog/programming/2015/05/11/why-programming-is-hard.html</link>
        <guid isPermaLink="true">http://diezcami.github.io/blog/programming/2015/05/11/why-programming-is-hard.html</guid>
        
        
        <category>programming</category>
        
      </item>
    
      <item>
        <title>C++ Pointers and References: An Overview</title>
        <description>&lt;p&gt;References and pointers are usually, in one way or another, implemented in every programming language; higher level languages, however, most likely do not provide explicit access to them. As a result, they often come up implicitly in the form of garbage collection and simpler OOP conventions. On the other hand, languages that have more freedom at lower levels such as C/C++ allow users to explicitly use pointers and references to manually control several aspects of a program including, but not limited to memory management/allocation, OOP and ease of access. &lt;/p&gt;

&lt;p&gt;This guide is split into two parts - here, I&amp;#39;ll be going through a basic overview on pointers and references understandable to anyone with knowledge on basic programming in any language and minor C++ syntax (mainly std, cout and endl).&lt;/p&gt;

&lt;h2&gt;Pointers&lt;/h2&gt;

&lt;p&gt;Every declared variable in a program, whether primitive or not, is stored in memory and has its own memory address in the form of a hexadecimal number (0x). These variables are normally accessed by identifiers they&amp;#39;ve been declared with, paying no attention to its location in memory. To access the memory address of a variable in C++, we use the referencing operator &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;std::string foo = &amp;quot;foo&amp;quot;;
std::cout &amp;lt;&amp;lt; &amp;amp;foo &amp;lt;&amp;lt; std::endl; // output: memory address of foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;strong&gt;Pointer&lt;/strong&gt; is a variable that holds a memory address. Its behavior is relatable to how entries in a table of contents contain page numbers or addresses that lead to actual content. It can be declared with or without being defined using &lt;code&gt;data_type *identifier&lt;/code&gt;. To get the variable stored in a pointer, we use the dereferencing operator &lt;code&gt;*&lt;/code&gt;. Note that the &lt;code&gt;*&lt;/code&gt; being used as an operator and as part of a pointer&amp;#39;s declaration are independent of each other.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int num = 10;
int *foo;
int bar*; 
std::cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; std::endl; // output: 0x0 (null memory address)

foo = &amp;amp;num; 
std::cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; std::endl; // output: memory address of num
std::cout &amp;lt;&amp;lt; *foo &amp;lt;&amp;lt; std::endl; //output: 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pointers are not limited to being assigned by memory addresses derived from the &lt;code&gt;&amp;amp;&lt;/code&gt; operator - they can also be assigned with the memory addresses stored in other pointers. If a pointer is assigned to another pointer, any changes to the variable stored in the common memory address will reflect on the &lt;code&gt;*&lt;/code&gt; operation of either pointer. This behavior is reminiscent of how objects are handled handled in Java; &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;std::string qux = &amp;quot;Tempura&amp;quot;;
std::string *foo, *bar;

foo = &amp;amp;qux;
bar = foo;
std::cout &amp;lt;&amp;lt; *foo &amp;lt;&amp;lt; std::endl; // output: Tempura
std::cout &amp;lt;&amp;lt; *bar &amp;lt;&amp;lt; std:: endl; // output: Tempura

qux = &amp;quot;Tonkatsu&amp;quot;;
std::cout &amp;lt;&amp;lt; *foo &amp;lt;&amp;lt; std::endl; // output: Tonkatsu
std::cout &amp;lt;&amp;lt; *bar &amp;lt;&amp;lt; std:: endl; // output: Tonkatsu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The deferencing operator &lt;code&gt;*&lt;/code&gt; can also be used at the left hand side of operations to replace the values stored in a pointer or memory address. The referencing operator &lt;code&gt;&amp;amp;&lt;/code&gt;, however, cannot as it would not make sense to reallocate where a variable would be stored in memory. The following is a continuation of the code snippet above:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// Recall that foo = &amp;amp;qux
*foo = &amp;quot;Gyudon&amp;quot;;
std::cout &amp;lt;&amp;lt; qux &amp;lt;&amp;lt; std::endl; // output: Gyudon
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Pointer Practices&lt;/h2&gt;

&lt;p&gt;When using pointers regardless of how simple its applications are, it&amp;#39;s paramount to take caution in remembering where a pointer comes from and goes towards during assignments. Carelessness here will lead to dangling pointers and memory leaks, which can be detrimental to your program&amp;#39;s performance at best, and your whole computer&amp;#39;s at worst. As good practice, the two main points to remember when using pointers are the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Deallocating memory&lt;/strong&gt; used by an object a pointer points to using &lt;code&gt;delete pointer_to_obj&lt;/code&gt; or &lt;code&gt;delete[] pointer_to_obj&lt;/code&gt; after its usage to avoid memory leaks&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Setting a pointer to &lt;code&gt;null&lt;/code&gt;&lt;/strong&gt; after its usage to avoid dangling pointers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;#39;s important to note that either &lt;code&gt;delete&lt;/code&gt; function is actually interpreted as &lt;strong&gt;delete the object stored in pointer (arg)&lt;/strong&gt;, which is entirely different from deleting the pointer itself. It&amp;#39;s also important to note that either &lt;code&gt;delete&lt;/code&gt; function only works on objects allocated with &lt;code&gt;new&lt;/code&gt;. We use &lt;code&gt;delete&lt;/code&gt; for variables that take up one block of space (eg. int, double, subclasses) and &lt;code&gt;delete[]&lt;/code&gt; for array-based variables (eg. string, int[]). The following code snippet shows an example of inaccessible memory:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;std::string *bar = new std::string;
*bar = &amp;quot;..&amp;quot;;
std::cout &amp;lt;&amp;lt; *bar &amp;lt;&amp;lt; std::endl; 
bar = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example above, the string &lt;code&gt;..&lt;/code&gt; was initialized at the memory address stored in the pointer &lt;code&gt;bar&lt;/code&gt;. After pointing &lt;code&gt;bar&lt;/code&gt; to null (as stated in the second point in the guideline), there&amp;#39;s nothing left that points to the memory storing the string containing &lt;code&gt;..&lt;/code&gt;, making it impossible to deallocate and forced to remain in the RAM throughout the whole duration of the program. These situations are called &lt;strong&gt;Memory Leaks&lt;/strong&gt;, and can be remedied by following the first guideline as stated earlier as seen below:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;std::string *bar = new std::string;
*bar = &amp;quot;..&amp;quot;;
std::cout &amp;lt;&amp;lt; *bar &amp;lt;&amp;lt; std::endl; 
delete bar; // deletes the object pointed to by bar, not bar itself
bar = null
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another type of problem presented by mishandling pointers is the &lt;strong&gt;Dangling Pointer&lt;/strong&gt;, which happens when an pointer points to a memory address that, at the time of accessing, has not been allocated. It&amp;#39;s important to note that not being allocated is not equivalent to pointing to null. The following code snippet shows an example of a dangling pointer:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int *bar = new int(5);
delete bar;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the memory address stored in &lt;code&gt;bar&lt;/code&gt; has been freed with &lt;code&gt;delete bar&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; now points to a deallocated memory address. Dereferencing or assigning the address at this point may be unsafe and result in &lt;strong&gt;undefined behavior&lt;/strong&gt;, so it&amp;#39;s better to set &lt;code&gt;bar&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; to stay on the safer side of memory management.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int *bar = new int(5);
delete bar;
bar = 0;
std::cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; std::endl; // Output: 0x0 (null)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Beyond the band-aid fix of setting a pointer to null, however, it would be better to modify the code in a way that there would be no need to set the pointer to null to begin with. 
Most examples here are trivial and meant to showcase pointer syntax above anything else. In reality, pointers can be used in OOP and to allocate memory in more resource-hungry programs to maximise their performance.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;A &lt;strong&gt;Reference&lt;/strong&gt; holds another variable of the same declared type, and serves as its alias. Its behavior is relatable to how a person can (but may not) be referred to by multiple nicknames or aliases while maintaining one full name. It can be declared and must be defined using &lt;code&gt;data_type &amp;amp;identifier&lt;/code&gt;. Similarly with &lt;code&gt;*&lt;/code&gt;, note that the &lt;code&gt;&amp;amp;&lt;/code&gt; used when declaring a reference is not the same as the referencing operator &lt;code&gt;&amp;amp;&lt;/code&gt; used in the earlier examples. Unlike pointers, a reference cannot be null or re-assigned after being defined. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;std::string foo = &amp;quot;..&amp;quot;;
std::string&amp;amp; bar = foo;

bool foobar = (foo==bar);
std::cout &amp;lt;&amp;lt; foobar &amp;lt;&amp;lt; std::endl; // output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a way, references work similarly to pointers with more limitations and are &lt;code&gt;const&lt;/code&gt; in nature. The existence of references, however, is not fully redundant - operations involving references are generally safer than those involving pointers, and are usually used unless the situation demands functions exclusive to pointers (recall how pointers can be reassigned, while references cannot). References are also generally easier to use, as there&amp;#39;s no need to keep track of dangling pointers or inaccessible memory. While I won&amp;#39;t be going through the in-depth uses of references, I&amp;#39;ve written one instance that showcases their functionality and definition well.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;void swap_val (int foo, int bar) {
    int qux = foo;
    foo = bar;
    bar = qux;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When the above function &lt;code&gt;swap_val (a, b)&lt;/code&gt; is called in an external function, the parameters &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are merely copies of the values stored in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. As a result, calling this function will not result in swapping the actual values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; outside the function. When this behaviour happens in a function, it&amp;#39;s said that its parameters &lt;strong&gt;pass by value&lt;/strong&gt;. In the alternative function below,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;void swap_ref (int &amp;amp;foo, int &amp;amp;bar) {
    int qux = foo;
    foo = bar;
    bar = qux;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that references are passed instead of actual &lt;code&gt;int&lt;/code&gt; parameters. When &lt;code&gt;swap_ref (a, b)&lt;/code&gt; is called, what&amp;#39;s passed to the function are &lt;em&gt;references to a and b&lt;/em&gt;, and not just copies of their values. When this behavior occurs, a function&amp;#39;s parameters are said to &lt;strong&gt;pass by value&lt;/strong&gt;. Now, when the function calls operations on references of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, they are actually called on the variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; passed as parameters as well. As a result,&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;int foo = 10;
int bar = 20;
swap_val (foo, bar);
std::cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; std::endl; // Output: 10
std::cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; std::endl; // Output: 20

swap_ref (foo, bar);
swap_val (foo, bar);
std::cout &amp;lt;&amp;lt; foo &amp;lt;&amp;lt; std::endl; // Output: 20
std::cout &amp;lt;&amp;lt; bar &amp;lt;&amp;lt; std::endl; // Output: 10  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;References are normally inaccessible in languages that maintain high level functionalities (including Java), making the language &lt;strong&gt;pass by value&lt;/strong&gt; as a whole by default. What&amp;#39;s good about the availability of access to references in C++ is the option to pass parameters either by value or by reference to functions, resulting in more versatile ways to code.&lt;/p&gt;

&lt;h2&gt;Summary&lt;/h2&gt;

&lt;p&gt;Here&amp;#39;s a list of the terminologies used throughout the article:&lt;/p&gt;

&lt;table&gt;
    &lt;tr&gt;
        &lt;td width=24%&gt;&lt;strong&gt;TERM&lt;/strong&gt;&lt;/td&gt;
        &lt;td width=24%&gt;&lt;strong&gt;SAMPLE USAGE&lt;/strong&gt;&lt;/td&gt;
        &lt;td width=52%&gt;&lt;strong&gt;DEFINITION&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Pointer&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;int *foo&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;A data type that stores a memory address&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Reference (noun)&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;int &amp;foo&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;A data type that serves as an alias to another variable&lt;/td&gt;

    &lt;/tr&gt;



    &lt;tr&gt;
        &lt;td&gt;Dereference&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;*bar&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;To get the object stored in a memory address or pointer with the &lt;code&gt;*&lt;/code&gt; operator&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Memory Leak&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;n/a&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Result of memory addresses that can no longer be accessed and deallocated&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Dangling Pointers&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;n/a&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Result of deallocating a memory address a pointer is pointing to&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Undefined Behavior&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;n/a&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Result of illogical operations (eg. dereferencing a dangling pointer)&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Pass&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;foo (a, b)&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Action taken on parameters used when calling a function&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Pass by Value&lt;/td&gt;
        &lt;td&gt;&lt;code&gt;void (int foo)&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Behavior in which functions operate on copies or clones of passed parameters&lt;/td&gt;
    &lt;/tr&gt;

    &lt;tr&gt;
        &lt;td&gt;Pass by Reference &lt;/td&gt;
        &lt;td&gt;&lt;code&gt;void (int &amp;foo)&lt;/code&gt;&lt;/td&gt;
        &lt;td&gt;Behavior in which functions operate on aliases leading to the passed parameters&lt;/td&gt;
    &lt;/tr&gt;

&lt;/table&gt;

&lt;h2&gt;Further Reading&lt;/h2&gt;

&lt;p&gt;There&amp;#39;re a number of common applications for references and pointers that I did not cover in this entry - here&amp;#39;s a small list of those:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory Management: Stacks and Heaps&lt;/strong&gt;: In short, normal declared variables are allocated to the stack while variables called with &lt;code&gt;new&lt;/code&gt; and pointers are allocated in the heap. Reading up on this will allow you to have a better understanding of what happens on a lower level beyond the the code and how memory is managed through code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nesting (de)referencing operators&lt;/strong&gt;: It&amp;#39;s possible to call data types such as &lt;code&gt;type **identifier&lt;/code&gt; to create a pointer to a pointer, or to use combinations of &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; to create variable types that may eventually come in handy. Understanding how nested operators work will also provide a stronger foundation in C++ OOP than what&amp;#39;s covered in this article.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pointers and Arrays&lt;/strong&gt;: These two are closely related and reading up on them can explain the similarities in data types such as &lt;code&gt;char *&lt;/code&gt; and &lt;code&gt;int *&lt;/code&gt; when declaring an array or a pointer.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parameters and Return Values&lt;/strong&gt;: Pointers and References, like any other variable, can be used as parameters and return values when implementing functions. You will likely encounter terms such as &lt;em&gt;pass by value&lt;/em&gt; and &lt;em&gt;pass by reference&lt;/em&gt;, which were introduced briefly earlier in this guide.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Smart Pointers&lt;/strong&gt;: More modern pointers that can be configured to or automatically delete pointers after a specified event. These, for the most part, get rid of the dangerous side of memory management that come with using regular pointers.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 08 May 2015 11:33:15 +0800</pubDate>
        <link>http://diezcami.github.io/blog/programming/c++/2015/05/08/c-plus-plus-pointers-and-references-an-overview.html</link>
        <guid isPermaLink="true">http://diezcami.github.io/blog/programming/c++/2015/05/08/c-plus-plus-pointers-and-references-an-overview.html</guid>
        
        
        <category>programming</category>
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>OSX: Fixing Slow Wakes and Automatic Shutdowns</title>
        <description>&lt;p&gt;All these commands have been personally tested on my Macbook Pro running OSX Yosemite 10.10.3.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Slow Wakes&lt;/strong&gt; are implemented by default in OSX to maximize the lifespan of a machine&amp;#39;s battery, which to my knowledge is more difficult, if not impossible to replace in Apple&amp;#39;s newer product lines. On the other hand, &lt;strong&gt;Automatic Shutdowns&lt;/strong&gt; are a result of Apple complying with the European Energy Standards, as seen in the following text from their official documentation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;With the release of the OS X Mountain Lion v10.8.2 supplemental update 2.0, a new feature was introduced to enter safe sleep after four hours of the computer being connected to AC power. This is an effort to comply with the European Energy Standards (ErP Lot6). This will only occur if there is no wireless or Ethernet activity and no activity from external devices such as USB storage devices. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Depending on when and how you work, however, these features may get in the way of your productivity to the point where the benefits they bring to your machine&amp;#39;s battery are negligible compared to its disadvantages.
If you&amp;#39;re like me and use your machine daily for work or whatnot, you&amp;#39;ve probably started seeing these features in a negative light. If you&amp;#39;ve troubleshooted your system preferences to no avail, you&amp;#39;ll most likely have better luck tweaking the &lt;strong&gt;Power Management Settings&lt;/strong&gt; of your machine, which can be accessed through the Terminal with the following command: &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo pmset -g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After typing the command, input the password you use to log in and out of your Macbook, and hit &lt;code&gt;return&lt;/code&gt;. If everything checks out, your screen should show the actual configurations of your machine, as seen below.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Active Profiles:
Battery Power        -1
AC Power             -1*
Currently in use:
standbydelay         10800
standby              1
womp                 1
halfdim              1
hibernatefile        /var/vm/sleepimage
darkwakes            1
networkoversleep     0
disksleep            10
sleep                0 
autopoweroffdelay    172800
hibernatemode        3
autopoweroff         0
ttyskeepawake        1
displaysleep         10
acwake               0
lidwake              1
MacBook-Pro:~ Cami$ 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What &lt;code&gt;pmset&lt;/code&gt; shows, in a nutshell, are your configurations for standby, hibernation, sleep and power. Note that these numbers won&amp;#39;t be accurate as I&amp;#39;ve already configured them on my own; the actual settings, however, should be more or less identical. We&amp;#39;ll be using these configurations primarily to address the problems brought upon by the features I&amp;#39;ve mentioned in the beginning of this post.&lt;/p&gt;

&lt;h2&gt;Fixing Automatic Shutdowns&lt;/h2&gt;

&lt;p&gt;The automatic shutdown &amp;#39;feature&amp;#39; proved to be detrimental to me as I had to rearrange and reopen my windows daily (sometimes bidaily) and check for any lost data prior to putting my machine into sleep mode. I&amp;#39;ve tried resetting the SMC and NVRAM to no avail, along with tweaking some settings in System Preferences that haven&amp;#39;t been touched before the behaviour started. We&amp;#39;ll be using &lt;code&gt;pmset&lt;/code&gt; to solve configure the settings for this feature, as seen below.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;autopoweroff&lt;/code&gt; line refers to whether your system automatically shuts down or enters the &amp;#39;safe sleep mode&amp;#39; after being in ordinary sleep mode for the number of seconds specified in &lt;code&gt;autopoweroffdelay&lt;/code&gt;. Since Apple enabled this feature by default, the value in your terminal for &lt;code&gt;autopoweroff&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;. To disable it, the value needs to be changed to &lt;code&gt;0&lt;/code&gt; with the following command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo pmset -a autopoweroff 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Despite using this command, however, I found that the auto-sleep behaviour still persisted on my Macbook. If you want to stay on the safe side, I recommend you tweak your configurations for the &lt;code&gt;autopoweroffdelay&lt;/code&gt; setting as well.
The default value for &lt;code&gt;autopoweroffdelay&lt;/code&gt; is 14400, which is equivalent to 4 hours as stated in the official documentation. If you&amp;#39;re not interested in having your machine shut down automatically in the middle of the day, you can tweak the time value for this setting by using the following command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo pmset -a autopoweroffdelay 172800
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I changed the delay from 14400 to 172800, which is equivalent to 2 days. You can change time value to whatever suits your working habits using the same command as many times as you&amp;#39;d like. The two commands above should cover your issues concerning automatic shutdowns using &lt;code&gt;pmset&lt;/code&gt;; if you still have problems, you may want to check your &lt;strong&gt;System Preferences&lt;/strong&gt; for scheduled shutdowns.&lt;/p&gt;

&lt;h2&gt;Fixing Slow Wakes&lt;/h2&gt;

&lt;p&gt;The other common problem (or battery saving feature, depending on how you look at it) is the slow wake. This happens when your Macbook takes a while to boot up after opening the lid, and can be fixed by editing the configurations stored in &lt;code&gt;pmset&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;When going into standby mode, your computer stores the contents in its RAM into the Hard Drive in order to save battery. Booting up from the hard drive, however, takes time (even for Solid State Drives or Flash-Based Storage) compared to doing so from RAM, which causes the slow boot-up. If you&amp;#39;re fine with sacrificing battery life to get rid of this feature, you can turn it off with the following command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo pmset -a standby 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I don&amp;#39;t recommend this though, as leaving your Macbook unattended for long periods of time with this setting may cause the battery to drain faster and go through more cycles, resulting in lowering its lifespan. A more reasonable compromise would be setting up a time before standby mode kicks in, which can be set by typing the following command:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo pmset -a standbydelay 43200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This tells your computer to remain off standby mode for 12 hours after being put into sleep mode, which allows you to have fast wakes when you open your Macbook as soon as you wake up, assuming you stopped using it right before going to bed. Unlike the former command, however, this setting allows you to compromise your battery less while achieving similar results, depending on how you work. Like &lt;code&gt;autopoweroffdelay&lt;/code&gt;, however, this delay time can be set to anything, so feel free to tweak the commands.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;All the commands mentioned in this post will remain after shutting off your machine, so there&amp;#39;s no need to do the procedures after every boot-up. You can always confirm the settings by calling &lt;code&gt;sudo pmset -g&lt;/code&gt; in Terminal. I&amp;#39;ve covered most of what you need to know to fix the most noticeable sleep and wake issues implemented by default in OSX - if you want to mess with the other variables, you can read up on them &lt;a href=&quot;http://en.wikipedia.org/wiki/Pmset&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Apr 2015 14:29:21 +0800</pubDate>
        <link>http://diezcami.github.io/blog/osx/unix/2015/04/28/osx-fixing-slow-wakes-and-automatic-shutdowns.html</link>
        <guid isPermaLink="true">http://diezcami.github.io/blog/osx/unix/2015/04/28/osx-fixing-slow-wakes-and-automatic-shutdowns.html</guid>
        
        
        <category>osx</category>
        
        <category>unix</category>
        
      </item>
    
      <item>
        <title>Hello, World!</title>
        <description>&lt;p&gt;Hi, I&amp;#39;m Cami! This is the first pass of my attempt at making a personal blog. I&amp;#39;ve yet to learn how to work around the Octopress/Jekyll framework without looking up references often, but I&amp;#39;m certain I&amp;#39;ll find my way around them in due time. &lt;/p&gt;

&lt;p&gt;In addition to learning how to deploy a project with &lt;code&gt;git&lt;/code&gt;, I&amp;#39;m also hoping to improve my writing skills and programming practices as I contribute to this blog. &lt;/p&gt;

&lt;p&gt;I hope you enjoy your stay here!&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Apr 2015 20:48:06 +0800</pubDate>
        <link>http://diezcami.github.io/blog/2015/04/27/hello.html</link>
        <guid isPermaLink="true">http://diezcami.github.io/blog/2015/04/27/hello.html</guid>
        
        
      </item>
    
  </channel>
</rss>
